package rflib.common.hscript;

extern class Parser {
	var allowJSON : Bool;
	var allowTypes : Bool;
	private var char : Int;
	var identChars : String;
	private var idents : Array<Bool>;
	private var input : haxe.io.Input;
	private var length : Int;
	var line : Int;
	private var oldTokenMax : Int;
	private var oldTokenMin : Int;
	var opChars : String;
	var opPriority : Map<String,Int>;
	var opRightAssoc : Map<String,Bool>;
	private var ops : Array<Bool>;
	private var origin : String;
	private var readPos : Int;
	private var tokenMax : Int;
	private var tokenMin : Int;
	private var tokens : List<{t : Token, min : Int, max : Int}>;
	private var uid : Int;
	var unops : Map<String,Bool>;
	function new() : Void;
	private function _token() : Token;
	private function constString(c : Const) : String;
	private function ensure(tk : Token) : Void;
	function error(err : ErrorDef, pmin : Int, pmax : Int) : Void;
	private function incPos() : Void;
	function invalidChar(c : Int) : Void;
	private function makeBinop(op : String, e1 : Expr, e : Expr) : Expr;
	private function makeUnop(op : String, e : Expr) : Expr;
	private function mapCompr(tmp : String, e : Expr) : Expr;
	@:pure(inferredPure) private function mk(e : ExprDef, pmin : Null<Int> = 0, pmax : Null<Int> = 0) : Expr;
	function parse(s : haxe.io.Input, ?origin : String) : Expr;
	private function parseExpr() : Expr;
	private function parseExprList(etk : Token) : Array<Expr>;
	private function parseExprNext(e1 : Expr) : Expr;
	private function parseFullExpr() : Expr;
	private function parseObject(p1 : Null<Int>) : Expr;
	function parseString(s : String, ?origin : String, line : Int = 0) : Expr;
	private function parseStructure(id : String) : Null<Expr>;
	private function parseType() : CType;
	private function parseTypeNext(t : CType) : CType;
	@:pure(inferredPure) private function pmax(e : Expr) : Int;
	@:pure(inferredPure) private function pmin(e : Expr) : Int;
	private function push(tk : Token) : Void;
	private function readChar() : Int;
	private function readString(until : Int) : String;
	private function token() : Token;
	private function tokenComment(op : String, chr : Int) : Token;
	private function tokenString(t : Token) : String;
	private function unexpected(tk : Token) : Dynamic;
	@:pure(inferredPure) private static function expr(e : Expr) : ExprDef;
	@:pure(inferredPure) static function isBlock(e : Expr) : Bool;
}
